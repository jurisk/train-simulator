use bevy::prelude::*;
use bevy::render::mesh::PrimitiveTopology;
use bevy::render::render_asset::RenderAssetUsages;

// Later: Refactor to be more similar to other shapes, e.g. shape::Cube
// Generated by GPT-4
#[must_use]
#[expect(clippy::cast_precision_loss)]
pub fn generate_cone(radius: f32, height: f32, sectors: u32) -> Mesh {
    let mut mesh = Mesh::new(
        PrimitiveTopology::TriangleList,
        RenderAssetUsages::default(),
    );

    let mut positions: Vec<[f32; 3]> = Vec::with_capacity((sectors + 2) as usize);
    let mut normals: Vec<[f32; 3]> = Vec::with_capacity((sectors + 2) as usize);
    let mut indices: Vec<u32> = Vec::with_capacity(sectors as usize * 3);

    // top point
    positions.push([0.0, height / 2.0, 0.0]);
    normals.push([0.0, 1.0, 0.0]);

    // side points
    for i in 0 .. sectors {
        let sector_step = 2.0 * std::f32::consts::PI / (sectors as f32);
        let sector_angle = i as f32 * sector_step;

        let x = radius * sector_angle.cos();
        let z = radius * sector_angle.sin();

        positions.push([x, -height / 2.0, z]);

        let side_normal =
            Vec3::new(x, 0.0, z).normalize() * Vec3::new(1.0, height / radius, 1.0).normalize();
        normals.push(side_normal.into());
    }

    // bottom point
    positions.push([0.0, -height / 2.0, 0.0]);
    normals.push([0.0, -1.0, 0.0]);

    // top triangles
    for i in 0 .. sectors {
        let next_index = if i == sectors - 1 { 1 } else { i + 2 };
        indices.extend_from_slice(&[0, next_index, i + 1]);
    }

    // bottom triangles
    for i in 1 ..= sectors {
        let next_index = if i == sectors { 1 } else { i + 1 };
        indices.extend_from_slice(&[sectors + 1, i, next_index]);
    }

    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh.insert_indices(bevy::render::mesh::Indices::U32(indices));

    mesh
}
